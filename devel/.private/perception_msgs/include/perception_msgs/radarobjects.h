// Generated by gencpp from file perception_msgs/radarobjects.msg
// DO NOT EDIT!


#ifndef PERCEPTION_MSGS_MESSAGE_RADAROBJECTS_H
#define PERCEPTION_MSGS_MESSAGE_RADAROBJECTS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace perception_msgs
{
template <class ContainerAllocator>
struct radarobjects_
{
  typedef radarobjects_<ContainerAllocator> Type;

  radarobjects_()
    : u_StatusSensor(0)
    , u_ID(0)
    , u_Age(0)
    , u_StatusMeasurement(0)
    , u_StatusMovement(0)
    , u_Position_InvalidFlags(0)
    , u_Position_Reference(0)
    , u_Position_X(0.0)
    , u_Position_X_STD(0.0)
    , u_Position_Y(0.0)
    , u_Position_Y_STD(0.0)
    , u_Position_Z(0.0)
    , u_Position_Z_STD(0.0)
    , u_Position_CovarianceXY(0.0)
    , u_Position_Orientation(0.0)
    , u_Position_Orientation_STD(0.0)
    , u_Existence_InvalidFlags(0)
    , u_Existence_Probability(0.0)
    , u_Existence_PPV(0.0)
    , u_Classification_Car(0)
    , u_Classification_Truck(0)
    , u_Classification_Motorcycle(0)
    , u_Classification_Bicycle(0)
    , u_Classification_Pedestrian(0)
    , u_Classification_Animal(0)
    , u_Classification_Hazard(0)
    , u_Classification_Unknown(0)
    , u_Classification_Overdrivable(0)
    , u_Classification_Underdrivable(0)
    , u_Dynamics_AbsVel_InvalidFlags(0)
    , f_Dynamics_AbsVel_X(0.0)
    , f_Dynamics_AbsVel_X_STD(0.0)
    , f_Dynamics_AbsVel_Y(0.0)
    , f_Dynamics_AbsVel_Y_STD(0.0)
    , f_Dynamics_AbsVel_CovarianceXY(0.0)
    , u_Dynamics_RelVel_InvalidFlags(0)
    , f_Dynamics_RelVel_X(0.0)
    , f_Dynamics_RelVel_X_STD(0.0)
    , f_Dynamics_RelVel_Y(0.0)
    , f_Dynamics_RelVel_Y_STD(0.0)
    , f_Dynamics_RelVel_CovarianceXY(0.0)
    , u_Dynamics_AbsAccel_InvalidFlags(0)
    , f_Dynamics_AbsAccel_X(0.0)
    , f_Dynamics_AbsAccel_X_STD(0.0)
    , f_Dynamics_AbsAccel_Y(0.0)
    , f_Dynamics_AbsAccel_Y_STD(0.0)
    , f_Dynamics_AbsAccel_CovarianceXY(0.0)
    , u_Dynamics_RelAccel_InvalidFlags(0)
    , f_Dynamics_RelAccel_X(0.0)
    , f_Dynamics_RelAccel_X_STD(0.0)
    , f_Dynamics_RelAccel_Y(0.0)
    , f_Dynamics_RelAccel_Y_STD(0.0)
    , f_Dynamics_RelAccel_CovarianceXY(0.0)
    , u_Dynamics_Orientation_InvalidFlags(0)
    , u_Dynamics_Orientation_Rate_Mean(0.0)
    , u_Dynamics_Orientation_Rate_STD(0.0)
    , u_Shape_Length_Status(0)
    , u_Shape_Length_Edge_InvalidFlags(0)
    , u_Shape_Length_Edge_Mean(0.0)
    , u_Shape_Length_Edge_STD(0.0)
    , u_Shape_Width_Status(0)
    , u_Shape_Width_Edge_InvalidFlags(0)
    , u_Shape_Width_Edge_Mean(0.0)
    , u_Shape_Width_Edge_STD(0.0)  {
    }
  radarobjects_(const ContainerAllocator& _alloc)
    : u_StatusSensor(0)
    , u_ID(0)
    , u_Age(0)
    , u_StatusMeasurement(0)
    , u_StatusMovement(0)
    , u_Position_InvalidFlags(0)
    , u_Position_Reference(0)
    , u_Position_X(0.0)
    , u_Position_X_STD(0.0)
    , u_Position_Y(0.0)
    , u_Position_Y_STD(0.0)
    , u_Position_Z(0.0)
    , u_Position_Z_STD(0.0)
    , u_Position_CovarianceXY(0.0)
    , u_Position_Orientation(0.0)
    , u_Position_Orientation_STD(0.0)
    , u_Existence_InvalidFlags(0)
    , u_Existence_Probability(0.0)
    , u_Existence_PPV(0.0)
    , u_Classification_Car(0)
    , u_Classification_Truck(0)
    , u_Classification_Motorcycle(0)
    , u_Classification_Bicycle(0)
    , u_Classification_Pedestrian(0)
    , u_Classification_Animal(0)
    , u_Classification_Hazard(0)
    , u_Classification_Unknown(0)
    , u_Classification_Overdrivable(0)
    , u_Classification_Underdrivable(0)
    , u_Dynamics_AbsVel_InvalidFlags(0)
    , f_Dynamics_AbsVel_X(0.0)
    , f_Dynamics_AbsVel_X_STD(0.0)
    , f_Dynamics_AbsVel_Y(0.0)
    , f_Dynamics_AbsVel_Y_STD(0.0)
    , f_Dynamics_AbsVel_CovarianceXY(0.0)
    , u_Dynamics_RelVel_InvalidFlags(0)
    , f_Dynamics_RelVel_X(0.0)
    , f_Dynamics_RelVel_X_STD(0.0)
    , f_Dynamics_RelVel_Y(0.0)
    , f_Dynamics_RelVel_Y_STD(0.0)
    , f_Dynamics_RelVel_CovarianceXY(0.0)
    , u_Dynamics_AbsAccel_InvalidFlags(0)
    , f_Dynamics_AbsAccel_X(0.0)
    , f_Dynamics_AbsAccel_X_STD(0.0)
    , f_Dynamics_AbsAccel_Y(0.0)
    , f_Dynamics_AbsAccel_Y_STD(0.0)
    , f_Dynamics_AbsAccel_CovarianceXY(0.0)
    , u_Dynamics_RelAccel_InvalidFlags(0)
    , f_Dynamics_RelAccel_X(0.0)
    , f_Dynamics_RelAccel_X_STD(0.0)
    , f_Dynamics_RelAccel_Y(0.0)
    , f_Dynamics_RelAccel_Y_STD(0.0)
    , f_Dynamics_RelAccel_CovarianceXY(0.0)
    , u_Dynamics_Orientation_InvalidFlags(0)
    , u_Dynamics_Orientation_Rate_Mean(0.0)
    , u_Dynamics_Orientation_Rate_STD(0.0)
    , u_Shape_Length_Status(0)
    , u_Shape_Length_Edge_InvalidFlags(0)
    , u_Shape_Length_Edge_Mean(0.0)
    , u_Shape_Length_Edge_STD(0.0)
    , u_Shape_Width_Status(0)
    , u_Shape_Width_Edge_InvalidFlags(0)
    , u_Shape_Width_Edge_Mean(0.0)
    , u_Shape_Width_Edge_STD(0.0)  {
  (void)_alloc;
    }



   typedef uint16_t _u_StatusSensor_type;
  _u_StatusSensor_type u_StatusSensor;

   typedef uint32_t _u_ID_type;
  _u_ID_type u_ID;

   typedef uint16_t _u_Age_type;
  _u_Age_type u_Age;

   typedef uint8_t _u_StatusMeasurement_type;
  _u_StatusMeasurement_type u_StatusMeasurement;

   typedef uint8_t _u_StatusMovement_type;
  _u_StatusMovement_type u_StatusMovement;

   typedef uint16_t _u_Position_InvalidFlags_type;
  _u_Position_InvalidFlags_type u_Position_InvalidFlags;

   typedef uint8_t _u_Position_Reference_type;
  _u_Position_Reference_type u_Position_Reference;

   typedef float _u_Position_X_type;
  _u_Position_X_type u_Position_X;

   typedef float _u_Position_X_STD_type;
  _u_Position_X_STD_type u_Position_X_STD;

   typedef float _u_Position_Y_type;
  _u_Position_Y_type u_Position_Y;

   typedef float _u_Position_Y_STD_type;
  _u_Position_Y_STD_type u_Position_Y_STD;

   typedef float _u_Position_Z_type;
  _u_Position_Z_type u_Position_Z;

   typedef float _u_Position_Z_STD_type;
  _u_Position_Z_STD_type u_Position_Z_STD;

   typedef float _u_Position_CovarianceXY_type;
  _u_Position_CovarianceXY_type u_Position_CovarianceXY;

   typedef float _u_Position_Orientation_type;
  _u_Position_Orientation_type u_Position_Orientation;

   typedef float _u_Position_Orientation_STD_type;
  _u_Position_Orientation_STD_type u_Position_Orientation_STD;

   typedef uint8_t _u_Existence_InvalidFlags_type;
  _u_Existence_InvalidFlags_type u_Existence_InvalidFlags;

   typedef float _u_Existence_Probability_type;
  _u_Existence_Probability_type u_Existence_Probability;

   typedef float _u_Existence_PPV_type;
  _u_Existence_PPV_type u_Existence_PPV;

   typedef uint8_t _u_Classification_Car_type;
  _u_Classification_Car_type u_Classification_Car;

   typedef uint8_t _u_Classification_Truck_type;
  _u_Classification_Truck_type u_Classification_Truck;

   typedef uint8_t _u_Classification_Motorcycle_type;
  _u_Classification_Motorcycle_type u_Classification_Motorcycle;

   typedef uint8_t _u_Classification_Bicycle_type;
  _u_Classification_Bicycle_type u_Classification_Bicycle;

   typedef uint8_t _u_Classification_Pedestrian_type;
  _u_Classification_Pedestrian_type u_Classification_Pedestrian;

   typedef uint8_t _u_Classification_Animal_type;
  _u_Classification_Animal_type u_Classification_Animal;

   typedef uint8_t _u_Classification_Hazard_type;
  _u_Classification_Hazard_type u_Classification_Hazard;

   typedef uint8_t _u_Classification_Unknown_type;
  _u_Classification_Unknown_type u_Classification_Unknown;

   typedef uint8_t _u_Classification_Overdrivable_type;
  _u_Classification_Overdrivable_type u_Classification_Overdrivable;

   typedef uint8_t _u_Classification_Underdrivable_type;
  _u_Classification_Underdrivable_type u_Classification_Underdrivable;

   typedef uint8_t _u_Dynamics_AbsVel_InvalidFlags_type;
  _u_Dynamics_AbsVel_InvalidFlags_type u_Dynamics_AbsVel_InvalidFlags;

   typedef float _f_Dynamics_AbsVel_X_type;
  _f_Dynamics_AbsVel_X_type f_Dynamics_AbsVel_X;

   typedef float _f_Dynamics_AbsVel_X_STD_type;
  _f_Dynamics_AbsVel_X_STD_type f_Dynamics_AbsVel_X_STD;

   typedef float _f_Dynamics_AbsVel_Y_type;
  _f_Dynamics_AbsVel_Y_type f_Dynamics_AbsVel_Y;

   typedef float _f_Dynamics_AbsVel_Y_STD_type;
  _f_Dynamics_AbsVel_Y_STD_type f_Dynamics_AbsVel_Y_STD;

   typedef float _f_Dynamics_AbsVel_CovarianceXY_type;
  _f_Dynamics_AbsVel_CovarianceXY_type f_Dynamics_AbsVel_CovarianceXY;

   typedef uint8_t _u_Dynamics_RelVel_InvalidFlags_type;
  _u_Dynamics_RelVel_InvalidFlags_type u_Dynamics_RelVel_InvalidFlags;

   typedef float _f_Dynamics_RelVel_X_type;
  _f_Dynamics_RelVel_X_type f_Dynamics_RelVel_X;

   typedef float _f_Dynamics_RelVel_X_STD_type;
  _f_Dynamics_RelVel_X_STD_type f_Dynamics_RelVel_X_STD;

   typedef float _f_Dynamics_RelVel_Y_type;
  _f_Dynamics_RelVel_Y_type f_Dynamics_RelVel_Y;

   typedef float _f_Dynamics_RelVel_Y_STD_type;
  _f_Dynamics_RelVel_Y_STD_type f_Dynamics_RelVel_Y_STD;

   typedef float _f_Dynamics_RelVel_CovarianceXY_type;
  _f_Dynamics_RelVel_CovarianceXY_type f_Dynamics_RelVel_CovarianceXY;

   typedef uint8_t _u_Dynamics_AbsAccel_InvalidFlags_type;
  _u_Dynamics_AbsAccel_InvalidFlags_type u_Dynamics_AbsAccel_InvalidFlags;

   typedef float _f_Dynamics_AbsAccel_X_type;
  _f_Dynamics_AbsAccel_X_type f_Dynamics_AbsAccel_X;

   typedef float _f_Dynamics_AbsAccel_X_STD_type;
  _f_Dynamics_AbsAccel_X_STD_type f_Dynamics_AbsAccel_X_STD;

   typedef float _f_Dynamics_AbsAccel_Y_type;
  _f_Dynamics_AbsAccel_Y_type f_Dynamics_AbsAccel_Y;

   typedef float _f_Dynamics_AbsAccel_Y_STD_type;
  _f_Dynamics_AbsAccel_Y_STD_type f_Dynamics_AbsAccel_Y_STD;

   typedef float _f_Dynamics_AbsAccel_CovarianceXY_type;
  _f_Dynamics_AbsAccel_CovarianceXY_type f_Dynamics_AbsAccel_CovarianceXY;

   typedef uint8_t _u_Dynamics_RelAccel_InvalidFlags_type;
  _u_Dynamics_RelAccel_InvalidFlags_type u_Dynamics_RelAccel_InvalidFlags;

   typedef float _f_Dynamics_RelAccel_X_type;
  _f_Dynamics_RelAccel_X_type f_Dynamics_RelAccel_X;

   typedef float _f_Dynamics_RelAccel_X_STD_type;
  _f_Dynamics_RelAccel_X_STD_type f_Dynamics_RelAccel_X_STD;

   typedef float _f_Dynamics_RelAccel_Y_type;
  _f_Dynamics_RelAccel_Y_type f_Dynamics_RelAccel_Y;

   typedef float _f_Dynamics_RelAccel_Y_STD_type;
  _f_Dynamics_RelAccel_Y_STD_type f_Dynamics_RelAccel_Y_STD;

   typedef float _f_Dynamics_RelAccel_CovarianceXY_type;
  _f_Dynamics_RelAccel_CovarianceXY_type f_Dynamics_RelAccel_CovarianceXY;

   typedef uint8_t _u_Dynamics_Orientation_InvalidFlags_type;
  _u_Dynamics_Orientation_InvalidFlags_type u_Dynamics_Orientation_InvalidFlags;

   typedef float _u_Dynamics_Orientation_Rate_Mean_type;
  _u_Dynamics_Orientation_Rate_Mean_type u_Dynamics_Orientation_Rate_Mean;

   typedef float _u_Dynamics_Orientation_Rate_STD_type;
  _u_Dynamics_Orientation_Rate_STD_type u_Dynamics_Orientation_Rate_STD;

   typedef uint32_t _u_Shape_Length_Status_type;
  _u_Shape_Length_Status_type u_Shape_Length_Status;

   typedef uint8_t _u_Shape_Length_Edge_InvalidFlags_type;
  _u_Shape_Length_Edge_InvalidFlags_type u_Shape_Length_Edge_InvalidFlags;

   typedef float _u_Shape_Length_Edge_Mean_type;
  _u_Shape_Length_Edge_Mean_type u_Shape_Length_Edge_Mean;

   typedef float _u_Shape_Length_Edge_STD_type;
  _u_Shape_Length_Edge_STD_type u_Shape_Length_Edge_STD;

   typedef uint32_t _u_Shape_Width_Status_type;
  _u_Shape_Width_Status_type u_Shape_Width_Status;

   typedef uint8_t _u_Shape_Width_Edge_InvalidFlags_type;
  _u_Shape_Width_Edge_InvalidFlags_type u_Shape_Width_Edge_InvalidFlags;

   typedef float _u_Shape_Width_Edge_Mean_type;
  _u_Shape_Width_Edge_Mean_type u_Shape_Width_Edge_Mean;

   typedef float _u_Shape_Width_Edge_STD_type;
  _u_Shape_Width_Edge_STD_type u_Shape_Width_Edge_STD;





  typedef boost::shared_ptr< ::perception_msgs::radarobjects_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::perception_msgs::radarobjects_<ContainerAllocator> const> ConstPtr;

}; // struct radarobjects_

typedef ::perception_msgs::radarobjects_<std::allocator<void> > radarobjects;

typedef boost::shared_ptr< ::perception_msgs::radarobjects > radarobjectsPtr;
typedef boost::shared_ptr< ::perception_msgs::radarobjects const> radarobjectsConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::perception_msgs::radarobjects_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::perception_msgs::radarobjects_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::perception_msgs::radarobjects_<ContainerAllocator1> & lhs, const ::perception_msgs::radarobjects_<ContainerAllocator2> & rhs)
{
  return lhs.u_StatusSensor == rhs.u_StatusSensor &&
    lhs.u_ID == rhs.u_ID &&
    lhs.u_Age == rhs.u_Age &&
    lhs.u_StatusMeasurement == rhs.u_StatusMeasurement &&
    lhs.u_StatusMovement == rhs.u_StatusMovement &&
    lhs.u_Position_InvalidFlags == rhs.u_Position_InvalidFlags &&
    lhs.u_Position_Reference == rhs.u_Position_Reference &&
    lhs.u_Position_X == rhs.u_Position_X &&
    lhs.u_Position_X_STD == rhs.u_Position_X_STD &&
    lhs.u_Position_Y == rhs.u_Position_Y &&
    lhs.u_Position_Y_STD == rhs.u_Position_Y_STD &&
    lhs.u_Position_Z == rhs.u_Position_Z &&
    lhs.u_Position_Z_STD == rhs.u_Position_Z_STD &&
    lhs.u_Position_CovarianceXY == rhs.u_Position_CovarianceXY &&
    lhs.u_Position_Orientation == rhs.u_Position_Orientation &&
    lhs.u_Position_Orientation_STD == rhs.u_Position_Orientation_STD &&
    lhs.u_Existence_InvalidFlags == rhs.u_Existence_InvalidFlags &&
    lhs.u_Existence_Probability == rhs.u_Existence_Probability &&
    lhs.u_Existence_PPV == rhs.u_Existence_PPV &&
    lhs.u_Classification_Car == rhs.u_Classification_Car &&
    lhs.u_Classification_Truck == rhs.u_Classification_Truck &&
    lhs.u_Classification_Motorcycle == rhs.u_Classification_Motorcycle &&
    lhs.u_Classification_Bicycle == rhs.u_Classification_Bicycle &&
    lhs.u_Classification_Pedestrian == rhs.u_Classification_Pedestrian &&
    lhs.u_Classification_Animal == rhs.u_Classification_Animal &&
    lhs.u_Classification_Hazard == rhs.u_Classification_Hazard &&
    lhs.u_Classification_Unknown == rhs.u_Classification_Unknown &&
    lhs.u_Classification_Overdrivable == rhs.u_Classification_Overdrivable &&
    lhs.u_Classification_Underdrivable == rhs.u_Classification_Underdrivable &&
    lhs.u_Dynamics_AbsVel_InvalidFlags == rhs.u_Dynamics_AbsVel_InvalidFlags &&
    lhs.f_Dynamics_AbsVel_X == rhs.f_Dynamics_AbsVel_X &&
    lhs.f_Dynamics_AbsVel_X_STD == rhs.f_Dynamics_AbsVel_X_STD &&
    lhs.f_Dynamics_AbsVel_Y == rhs.f_Dynamics_AbsVel_Y &&
    lhs.f_Dynamics_AbsVel_Y_STD == rhs.f_Dynamics_AbsVel_Y_STD &&
    lhs.f_Dynamics_AbsVel_CovarianceXY == rhs.f_Dynamics_AbsVel_CovarianceXY &&
    lhs.u_Dynamics_RelVel_InvalidFlags == rhs.u_Dynamics_RelVel_InvalidFlags &&
    lhs.f_Dynamics_RelVel_X == rhs.f_Dynamics_RelVel_X &&
    lhs.f_Dynamics_RelVel_X_STD == rhs.f_Dynamics_RelVel_X_STD &&
    lhs.f_Dynamics_RelVel_Y == rhs.f_Dynamics_RelVel_Y &&
    lhs.f_Dynamics_RelVel_Y_STD == rhs.f_Dynamics_RelVel_Y_STD &&
    lhs.f_Dynamics_RelVel_CovarianceXY == rhs.f_Dynamics_RelVel_CovarianceXY &&
    lhs.u_Dynamics_AbsAccel_InvalidFlags == rhs.u_Dynamics_AbsAccel_InvalidFlags &&
    lhs.f_Dynamics_AbsAccel_X == rhs.f_Dynamics_AbsAccel_X &&
    lhs.f_Dynamics_AbsAccel_X_STD == rhs.f_Dynamics_AbsAccel_X_STD &&
    lhs.f_Dynamics_AbsAccel_Y == rhs.f_Dynamics_AbsAccel_Y &&
    lhs.f_Dynamics_AbsAccel_Y_STD == rhs.f_Dynamics_AbsAccel_Y_STD &&
    lhs.f_Dynamics_AbsAccel_CovarianceXY == rhs.f_Dynamics_AbsAccel_CovarianceXY &&
    lhs.u_Dynamics_RelAccel_InvalidFlags == rhs.u_Dynamics_RelAccel_InvalidFlags &&
    lhs.f_Dynamics_RelAccel_X == rhs.f_Dynamics_RelAccel_X &&
    lhs.f_Dynamics_RelAccel_X_STD == rhs.f_Dynamics_RelAccel_X_STD &&
    lhs.f_Dynamics_RelAccel_Y == rhs.f_Dynamics_RelAccel_Y &&
    lhs.f_Dynamics_RelAccel_Y_STD == rhs.f_Dynamics_RelAccel_Y_STD &&
    lhs.f_Dynamics_RelAccel_CovarianceXY == rhs.f_Dynamics_RelAccel_CovarianceXY &&
    lhs.u_Dynamics_Orientation_InvalidFlags == rhs.u_Dynamics_Orientation_InvalidFlags &&
    lhs.u_Dynamics_Orientation_Rate_Mean == rhs.u_Dynamics_Orientation_Rate_Mean &&
    lhs.u_Dynamics_Orientation_Rate_STD == rhs.u_Dynamics_Orientation_Rate_STD &&
    lhs.u_Shape_Length_Status == rhs.u_Shape_Length_Status &&
    lhs.u_Shape_Length_Edge_InvalidFlags == rhs.u_Shape_Length_Edge_InvalidFlags &&
    lhs.u_Shape_Length_Edge_Mean == rhs.u_Shape_Length_Edge_Mean &&
    lhs.u_Shape_Length_Edge_STD == rhs.u_Shape_Length_Edge_STD &&
    lhs.u_Shape_Width_Status == rhs.u_Shape_Width_Status &&
    lhs.u_Shape_Width_Edge_InvalidFlags == rhs.u_Shape_Width_Edge_InvalidFlags &&
    lhs.u_Shape_Width_Edge_Mean == rhs.u_Shape_Width_Edge_Mean &&
    lhs.u_Shape_Width_Edge_STD == rhs.u_Shape_Width_Edge_STD;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::perception_msgs::radarobjects_<ContainerAllocator1> & lhs, const ::perception_msgs::radarobjects_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace perception_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::perception_msgs::radarobjects_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::perception_msgs::radarobjects_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::perception_msgs::radarobjects_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::perception_msgs::radarobjects_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::perception_msgs::radarobjects_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::perception_msgs::radarobjects_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::perception_msgs::radarobjects_<ContainerAllocator> >
{
  static const char* value()
  {
    return "9f1b2a221636ef6b3eb48c9a44c02c32";
  }

  static const char* value(const ::perception_msgs::radarobjects_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x9f1b2a221636ef6bULL;
  static const uint64_t static_value2 = 0x3eb48c9a44c02c32ULL;
};

template<class ContainerAllocator>
struct DataType< ::perception_msgs::radarobjects_<ContainerAllocator> >
{
  static const char* value()
  {
    return "perception_msgs/radarobjects";
  }

  static const char* value(const ::perception_msgs::radarobjects_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::perception_msgs::radarobjects_<ContainerAllocator> >
{
  static const char* value()
  {
    return "uint16 u_StatusSensor\n"
"uint32 u_ID\n"
"uint16 u_Age\n"
"uint8 u_StatusMeasurement\n"
"uint8 u_StatusMovement\n"
"uint16 u_Position_InvalidFlags\n"
"uint8 u_Position_Reference\n"
"float32 u_Position_X\n"
"float32 u_Position_X_STD\n"
"float32 u_Position_Y\n"
"float32 u_Position_Y_STD\n"
"float32 u_Position_Z\n"
"float32 u_Position_Z_STD\n"
"float32 u_Position_CovarianceXY\n"
"float32 u_Position_Orientation\n"
"float32 u_Position_Orientation_STD\n"
"uint8 u_Existence_InvalidFlags\n"
"float32 u_Existence_Probability\n"
"float32 u_Existence_PPV\n"
"uint8 u_Classification_Car\n"
"uint8 u_Classification_Truck\n"
"uint8 u_Classification_Motorcycle\n"
"uint8 u_Classification_Bicycle\n"
"uint8 u_Classification_Pedestrian\n"
"uint8 u_Classification_Animal\n"
"uint8 u_Classification_Hazard\n"
"uint8 u_Classification_Unknown\n"
"uint8 u_Classification_Overdrivable\n"
"uint8 u_Classification_Underdrivable\n"
"uint8 u_Dynamics_AbsVel_InvalidFlags\n"
"float32 f_Dynamics_AbsVel_X\n"
"float32 f_Dynamics_AbsVel_X_STD\n"
"float32 f_Dynamics_AbsVel_Y\n"
"float32 f_Dynamics_AbsVel_Y_STD\n"
"float32 f_Dynamics_AbsVel_CovarianceXY\n"
"uint8 u_Dynamics_RelVel_InvalidFlags\n"
"float32 f_Dynamics_RelVel_X\n"
"float32 f_Dynamics_RelVel_X_STD\n"
"float32 f_Dynamics_RelVel_Y\n"
"float32 f_Dynamics_RelVel_Y_STD\n"
"float32 f_Dynamics_RelVel_CovarianceXY\n"
"uint8 u_Dynamics_AbsAccel_InvalidFlags\n"
"float32 f_Dynamics_AbsAccel_X\n"
"float32 f_Dynamics_AbsAccel_X_STD\n"
"float32 f_Dynamics_AbsAccel_Y\n"
"float32 f_Dynamics_AbsAccel_Y_STD\n"
"float32 f_Dynamics_AbsAccel_CovarianceXY\n"
"uint8 u_Dynamics_RelAccel_InvalidFlags\n"
"float32 f_Dynamics_RelAccel_X\n"
"float32 f_Dynamics_RelAccel_X_STD\n"
"float32 f_Dynamics_RelAccel_Y\n"
"float32 f_Dynamics_RelAccel_Y_STD\n"
"float32 f_Dynamics_RelAccel_CovarianceXY\n"
"uint8 u_Dynamics_Orientation_InvalidFlags\n"
"float32 u_Dynamics_Orientation_Rate_Mean\n"
"float32 u_Dynamics_Orientation_Rate_STD\n"
"uint32 u_Shape_Length_Status\n"
"uint8 u_Shape_Length_Edge_InvalidFlags\n"
"float32 u_Shape_Length_Edge_Mean\n"
"float32 u_Shape_Length_Edge_STD\n"
"uint32 u_Shape_Width_Status\n"
"uint8 u_Shape_Width_Edge_InvalidFlags\n"
"float32 u_Shape_Width_Edge_Mean\n"
"float32 u_Shape_Width_Edge_STD\n"
;
  }

  static const char* value(const ::perception_msgs::radarobjects_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::perception_msgs::radarobjects_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.u_StatusSensor);
      stream.next(m.u_ID);
      stream.next(m.u_Age);
      stream.next(m.u_StatusMeasurement);
      stream.next(m.u_StatusMovement);
      stream.next(m.u_Position_InvalidFlags);
      stream.next(m.u_Position_Reference);
      stream.next(m.u_Position_X);
      stream.next(m.u_Position_X_STD);
      stream.next(m.u_Position_Y);
      stream.next(m.u_Position_Y_STD);
      stream.next(m.u_Position_Z);
      stream.next(m.u_Position_Z_STD);
      stream.next(m.u_Position_CovarianceXY);
      stream.next(m.u_Position_Orientation);
      stream.next(m.u_Position_Orientation_STD);
      stream.next(m.u_Existence_InvalidFlags);
      stream.next(m.u_Existence_Probability);
      stream.next(m.u_Existence_PPV);
      stream.next(m.u_Classification_Car);
      stream.next(m.u_Classification_Truck);
      stream.next(m.u_Classification_Motorcycle);
      stream.next(m.u_Classification_Bicycle);
      stream.next(m.u_Classification_Pedestrian);
      stream.next(m.u_Classification_Animal);
      stream.next(m.u_Classification_Hazard);
      stream.next(m.u_Classification_Unknown);
      stream.next(m.u_Classification_Overdrivable);
      stream.next(m.u_Classification_Underdrivable);
      stream.next(m.u_Dynamics_AbsVel_InvalidFlags);
      stream.next(m.f_Dynamics_AbsVel_X);
      stream.next(m.f_Dynamics_AbsVel_X_STD);
      stream.next(m.f_Dynamics_AbsVel_Y);
      stream.next(m.f_Dynamics_AbsVel_Y_STD);
      stream.next(m.f_Dynamics_AbsVel_CovarianceXY);
      stream.next(m.u_Dynamics_RelVel_InvalidFlags);
      stream.next(m.f_Dynamics_RelVel_X);
      stream.next(m.f_Dynamics_RelVel_X_STD);
      stream.next(m.f_Dynamics_RelVel_Y);
      stream.next(m.f_Dynamics_RelVel_Y_STD);
      stream.next(m.f_Dynamics_RelVel_CovarianceXY);
      stream.next(m.u_Dynamics_AbsAccel_InvalidFlags);
      stream.next(m.f_Dynamics_AbsAccel_X);
      stream.next(m.f_Dynamics_AbsAccel_X_STD);
      stream.next(m.f_Dynamics_AbsAccel_Y);
      stream.next(m.f_Dynamics_AbsAccel_Y_STD);
      stream.next(m.f_Dynamics_AbsAccel_CovarianceXY);
      stream.next(m.u_Dynamics_RelAccel_InvalidFlags);
      stream.next(m.f_Dynamics_RelAccel_X);
      stream.next(m.f_Dynamics_RelAccel_X_STD);
      stream.next(m.f_Dynamics_RelAccel_Y);
      stream.next(m.f_Dynamics_RelAccel_Y_STD);
      stream.next(m.f_Dynamics_RelAccel_CovarianceXY);
      stream.next(m.u_Dynamics_Orientation_InvalidFlags);
      stream.next(m.u_Dynamics_Orientation_Rate_Mean);
      stream.next(m.u_Dynamics_Orientation_Rate_STD);
      stream.next(m.u_Shape_Length_Status);
      stream.next(m.u_Shape_Length_Edge_InvalidFlags);
      stream.next(m.u_Shape_Length_Edge_Mean);
      stream.next(m.u_Shape_Length_Edge_STD);
      stream.next(m.u_Shape_Width_Status);
      stream.next(m.u_Shape_Width_Edge_InvalidFlags);
      stream.next(m.u_Shape_Width_Edge_Mean);
      stream.next(m.u_Shape_Width_Edge_STD);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct radarobjects_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::perception_msgs::radarobjects_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::perception_msgs::radarobjects_<ContainerAllocator>& v)
  {
    s << indent << "u_StatusSensor: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.u_StatusSensor);
    s << indent << "u_ID: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.u_ID);
    s << indent << "u_Age: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.u_Age);
    s << indent << "u_StatusMeasurement: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_StatusMeasurement);
    s << indent << "u_StatusMovement: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_StatusMovement);
    s << indent << "u_Position_InvalidFlags: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.u_Position_InvalidFlags);
    s << indent << "u_Position_Reference: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Position_Reference);
    s << indent << "u_Position_X: ";
    Printer<float>::stream(s, indent + "  ", v.u_Position_X);
    s << indent << "u_Position_X_STD: ";
    Printer<float>::stream(s, indent + "  ", v.u_Position_X_STD);
    s << indent << "u_Position_Y: ";
    Printer<float>::stream(s, indent + "  ", v.u_Position_Y);
    s << indent << "u_Position_Y_STD: ";
    Printer<float>::stream(s, indent + "  ", v.u_Position_Y_STD);
    s << indent << "u_Position_Z: ";
    Printer<float>::stream(s, indent + "  ", v.u_Position_Z);
    s << indent << "u_Position_Z_STD: ";
    Printer<float>::stream(s, indent + "  ", v.u_Position_Z_STD);
    s << indent << "u_Position_CovarianceXY: ";
    Printer<float>::stream(s, indent + "  ", v.u_Position_CovarianceXY);
    s << indent << "u_Position_Orientation: ";
    Printer<float>::stream(s, indent + "  ", v.u_Position_Orientation);
    s << indent << "u_Position_Orientation_STD: ";
    Printer<float>::stream(s, indent + "  ", v.u_Position_Orientation_STD);
    s << indent << "u_Existence_InvalidFlags: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Existence_InvalidFlags);
    s << indent << "u_Existence_Probability: ";
    Printer<float>::stream(s, indent + "  ", v.u_Existence_Probability);
    s << indent << "u_Existence_PPV: ";
    Printer<float>::stream(s, indent + "  ", v.u_Existence_PPV);
    s << indent << "u_Classification_Car: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Classification_Car);
    s << indent << "u_Classification_Truck: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Classification_Truck);
    s << indent << "u_Classification_Motorcycle: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Classification_Motorcycle);
    s << indent << "u_Classification_Bicycle: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Classification_Bicycle);
    s << indent << "u_Classification_Pedestrian: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Classification_Pedestrian);
    s << indent << "u_Classification_Animal: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Classification_Animal);
    s << indent << "u_Classification_Hazard: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Classification_Hazard);
    s << indent << "u_Classification_Unknown: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Classification_Unknown);
    s << indent << "u_Classification_Overdrivable: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Classification_Overdrivable);
    s << indent << "u_Classification_Underdrivable: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Classification_Underdrivable);
    s << indent << "u_Dynamics_AbsVel_InvalidFlags: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Dynamics_AbsVel_InvalidFlags);
    s << indent << "f_Dynamics_AbsVel_X: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_AbsVel_X);
    s << indent << "f_Dynamics_AbsVel_X_STD: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_AbsVel_X_STD);
    s << indent << "f_Dynamics_AbsVel_Y: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_AbsVel_Y);
    s << indent << "f_Dynamics_AbsVel_Y_STD: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_AbsVel_Y_STD);
    s << indent << "f_Dynamics_AbsVel_CovarianceXY: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_AbsVel_CovarianceXY);
    s << indent << "u_Dynamics_RelVel_InvalidFlags: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Dynamics_RelVel_InvalidFlags);
    s << indent << "f_Dynamics_RelVel_X: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_RelVel_X);
    s << indent << "f_Dynamics_RelVel_X_STD: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_RelVel_X_STD);
    s << indent << "f_Dynamics_RelVel_Y: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_RelVel_Y);
    s << indent << "f_Dynamics_RelVel_Y_STD: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_RelVel_Y_STD);
    s << indent << "f_Dynamics_RelVel_CovarianceXY: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_RelVel_CovarianceXY);
    s << indent << "u_Dynamics_AbsAccel_InvalidFlags: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Dynamics_AbsAccel_InvalidFlags);
    s << indent << "f_Dynamics_AbsAccel_X: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_AbsAccel_X);
    s << indent << "f_Dynamics_AbsAccel_X_STD: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_AbsAccel_X_STD);
    s << indent << "f_Dynamics_AbsAccel_Y: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_AbsAccel_Y);
    s << indent << "f_Dynamics_AbsAccel_Y_STD: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_AbsAccel_Y_STD);
    s << indent << "f_Dynamics_AbsAccel_CovarianceXY: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_AbsAccel_CovarianceXY);
    s << indent << "u_Dynamics_RelAccel_InvalidFlags: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Dynamics_RelAccel_InvalidFlags);
    s << indent << "f_Dynamics_RelAccel_X: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_RelAccel_X);
    s << indent << "f_Dynamics_RelAccel_X_STD: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_RelAccel_X_STD);
    s << indent << "f_Dynamics_RelAccel_Y: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_RelAccel_Y);
    s << indent << "f_Dynamics_RelAccel_Y_STD: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_RelAccel_Y_STD);
    s << indent << "f_Dynamics_RelAccel_CovarianceXY: ";
    Printer<float>::stream(s, indent + "  ", v.f_Dynamics_RelAccel_CovarianceXY);
    s << indent << "u_Dynamics_Orientation_InvalidFlags: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Dynamics_Orientation_InvalidFlags);
    s << indent << "u_Dynamics_Orientation_Rate_Mean: ";
    Printer<float>::stream(s, indent + "  ", v.u_Dynamics_Orientation_Rate_Mean);
    s << indent << "u_Dynamics_Orientation_Rate_STD: ";
    Printer<float>::stream(s, indent + "  ", v.u_Dynamics_Orientation_Rate_STD);
    s << indent << "u_Shape_Length_Status: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.u_Shape_Length_Status);
    s << indent << "u_Shape_Length_Edge_InvalidFlags: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Shape_Length_Edge_InvalidFlags);
    s << indent << "u_Shape_Length_Edge_Mean: ";
    Printer<float>::stream(s, indent + "  ", v.u_Shape_Length_Edge_Mean);
    s << indent << "u_Shape_Length_Edge_STD: ";
    Printer<float>::stream(s, indent + "  ", v.u_Shape_Length_Edge_STD);
    s << indent << "u_Shape_Width_Status: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.u_Shape_Width_Status);
    s << indent << "u_Shape_Width_Edge_InvalidFlags: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u_Shape_Width_Edge_InvalidFlags);
    s << indent << "u_Shape_Width_Edge_Mean: ";
    Printer<float>::stream(s, indent + "  ", v.u_Shape_Width_Edge_Mean);
    s << indent << "u_Shape_Width_Edge_STD: ";
    Printer<float>::stream(s, indent + "  ", v.u_Shape_Width_Edge_STD);
  }
};

} // namespace message_operations
} // namespace ros

#endif // PERCEPTION_MSGS_MESSAGE_RADAROBJECTS_H
